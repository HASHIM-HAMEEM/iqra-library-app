import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:library_registration_app/domain/entities/activity_log.dart';
import 'package:library_registration_app/domain/entities/student.dart';
import 'package:library_registration_app/domain/repositories/activity_log_repository.dart';
import 'package:library_registration_app/domain/repositories/student_repository.dart';
import 'package:library_registration_app/presentation/providers/database_provider.dart';
import 'package:library_registration_app/data/services/supabase_service.dart';
import 'package:uuid/uuid.dart';

class StudentsNotifier extends StateNotifier<AsyncValue<List<Student>>> {
  StudentsNotifier(this._studentRepository, this._activityLogRepository, this._supabaseService)
    : super(const AsyncValue.loading()) {
    _loadStudents();
  }
  final StudentRepository _studentRepository;
  final ActivityLogRepository _activityLogRepository;
  final SupabaseService _supabaseService;

  Future<void> _loadStudents() async {
    try {
      final students = await _studentRepository.getActiveStudents();
      state = AsyncValue.data(students);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> refresh() async {
    state = const AsyncValue.loading();
    await _loadStudents();
  }

  Future<String?> createStudent({
    required String firstName,
    required String lastName,
    required DateTime dateOfBirth,
    required String email,
    String? seatNumber,
    String? phone,
    String? address,
    String? profileImagePath,
    String? subscriptionPlan,
    DateTime? subscriptionStartDate,
    DateTime? subscriptionEndDate,
    double? subscriptionAmount,
    String? subscriptionStatus,
  }) async {
    try {
      // Check authentication before proceeding
      if (!_supabaseService.isInitialized) {
        throw Exception('Database service is not properly configured. Please contact support.');
      }
      
      final user = _supabaseService.currentUser;
      final session = _supabaseService.currentSession;
      
      if (user == null || session == null) {
        throw Exception('You must be signed in to create students. Please log in and try again.');
      }
      
      // Check if session is expired
      if (session.expiresAt != null) {
        final expiryTime = DateTime.fromMillisecondsSinceEpoch(session.expiresAt! * 1000);
        if (expiryTime.isBefore(DateTime.now())) {
          throw Exception('Your session has expired. Please log in again.');
        }
      }
      
      final now = DateTime.now();
      final student = Student(
        id: '', // Will be generated by repository
        firstName: firstName,
        lastName: lastName,
        dateOfBirth: dateOfBirth,
        email: email,
        seatNumber: seatNumber,
        phone: phone,
        address: address,
        profileImagePath: profileImagePath,
        createdAt: now,
        updatedAt: now,
        subscriptionPlan: subscriptionPlan,
        subscriptionStartDate: subscriptionStartDate,
        subscriptionEndDate: subscriptionEndDate,
        subscriptionAmount: subscriptionAmount,
        subscriptionStatus: subscriptionStatus,
      );

      final studentId = await _studentRepository.createStudent(student);

      // Log activity
      await _logActivity(
        ActivityType.studentCreated,
        'Student "${student.fullName}" was created',
        entityId: studentId,
        entityType: 'student',
        metadata: {'email': email, 'age': student.age},
      );

      await _loadStudents();
      return studentId;
    } catch (error) {
      rethrow;
    }
  }

  Future<void> updateStudent(Student student) async {
    try {
      final updatedStudent = student.copyWith(updatedAt: DateTime.now());
      await _studentRepository.updateStudent(updatedStudent);

      // Log activity
      await _logActivity(
        ActivityType.studentUpdated,
        'Student "${student.fullName}" was updated',
        entityId: student.id,
        entityType: 'student',
        metadata: {'email': student.email, 'age': student.age},
      );

      await _loadStudents();
    } catch (error) {
      rethrow;
    }
  }

  Future<void> deleteStudent(String studentId, {bool hard = false}) async {
    try {
      final student = await _studentRepository.getStudentById(studentId);
      if (student == null) return;

      await _studentRepository.deleteStudent(studentId, hard: hard);

      // Log activity
      await _logActivity(
        ActivityType.studentDeleted,
        'Student "${student.fullName}" was ${hard ? 'permanently deleted' : 'deleted'}',
        entityId: studentId,
        entityType: 'student',
        metadata: {'email': student.email, 'hard_delete': hard},
      );

      await _loadStudents();
    } catch (error) {
      rethrow;
    }
  }

  Future<void> restoreStudent(String studentId) async {
    try {
      final student = await _studentRepository.getStudentById(studentId);
      if (student == null) return;

      await _studentRepository.restoreStudent(studentId);

      // Log activity
      await _logActivity(
        ActivityType.studentRestored,
        'Student "${student.fullName}" was restored',
        entityId: studentId,
        entityType: 'student',
        metadata: {'email': student.email},
      );

      await _loadStudents();
    } catch (error) {
      rethrow;
    }
  }

  Future<bool> isEmailExists(String email, {String? excludeId}) async {
    try {
      return await _studentRepository.isEmailExists(
        email,
        excludeId: excludeId,
      );
    } catch (error) {
      return false;
    }
  }

  Future<List<Student>> searchStudents(String query) async {
    try {
      if (query.isEmpty) {
        return await _studentRepository.getActiveStudents();
      }
      return await _studentRepository.searchStudents(query);
    } catch (error) {
      return [];
    }
  }

  Future<void> _logActivity(
    ActivityType type,
    String description, {
    String? entityId,
    String? entityType,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final activityLog = ActivityLog(
        id: const Uuid().v4(),
        activityType: type,
        description: description,
        entityId: entityId,
        entityType: entityType,
        timestamp: DateTime.now(),
        metadata: metadata,
      );
      await _activityLogRepository.createActivityLog(activityLog);
    } catch (e) {
      // Log activity errors shouldn't block the main operation
      print('Failed to log activity: $e');
    }
  }
}

// Students notifier provider
final studentsNotifierProvider =
    StateNotifierProvider<StudentsNotifier, AsyncValue<List<Student>>>((ref) {
      final studentRepository = ref.watch(studentRepositoryProvider);
      final activityLogRepository = ref.watch(activityLogRepositoryProvider);
      final supabaseService = ref.watch(supabaseServiceProvider);
      return StudentsNotifier(studentRepository, activityLogRepository, supabaseService);
    });
