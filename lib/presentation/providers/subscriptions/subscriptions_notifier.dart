import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:library_registration_app/domain/entities/activity_log.dart';
import 'package:library_registration_app/domain/entities/subscription.dart';
import 'package:library_registration_app/domain/repositories/activity_log_repository.dart';
import 'package:library_registration_app/domain/repositories/subscription_repository.dart';
import 'package:library_registration_app/presentation/providers/database_provider.dart';

class SubscriptionsNotifier
    extends StateNotifier<AsyncValue<List<Subscription>>> {
  SubscriptionsNotifier(
    this._subscriptionRepository,
    this._activityLogRepository,
  ) : super(const AsyncValue.loading()) {
    _loadSubscriptions();
  }
  final SubscriptionRepository _subscriptionRepository;
  final ActivityLogRepository _activityLogRepository;

  Future<void> _loadSubscriptions() async {
    try {
      final subscriptions = await _subscriptionRepository.getAllSubscriptions();
      state = AsyncValue.data(subscriptions);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  Future<void> refresh() async {
    state = const AsyncValue.loading();
    await _loadSubscriptions();
  }

  Future<String?> createSubscription({
    required String studentId,
    required String planName,
    required DateTime startDate,
    required DateTime endDate,
    required double amount,
    SubscriptionStatus status = SubscriptionStatus.active,
    bool allowOverlap = false,
  }) async {
    try {
      final now = DateTime.now();
      final subscription = Subscription(
        id: '', // Will be generated by repository
        studentId: studentId,
        planName: planName,
        startDate: startDate,
        endDate: endDate,
        amount: amount,
        status: status,
        createdAt: now,
        updatedAt: now,
      );

      final subscriptionId = await _subscriptionRepository.createSubscription(
        subscription,
        allowOverlap: allowOverlap,
      );

      // Log activity
      await _logActivity(
        ActivityType.subscriptionCreated,
        'Subscription "$planName" was created for student',
        entityId: subscriptionId,
        entityType: 'Subscription',
        metadata: {
          'student_id': studentId,
          'plan_name': planName,
          'amount': amount,
          'duration_days': endDate.difference(startDate).inDays,
        },
      );

      await _loadSubscriptions();
      return subscriptionId;
    } catch (error) {
      rethrow;
    }
  }

  Future<void> updateSubscription(Subscription subscription, {bool allowOverlap = false}) async {
    try {
      final updatedSubscription = subscription.copyWith(
        updatedAt: DateTime.now(),
      );
      await _subscriptionRepository.updateSubscription(
        updatedSubscription,
        allowOverlap: allowOverlap,
      );

      // Log activity
      await _logActivity(
        ActivityType.subscriptionUpdated,
        'Subscription "${subscription.planName}" was updated',
        entityId: subscription.id,
        entityType: 'Subscription',
        metadata: {
          'student_id': subscription.studentId,
          'plan_name': subscription.planName,
          'amount': subscription.amount,
          'status': subscription.status.name,
        },
      );

      await _loadSubscriptions();
    } catch (error) {
      rethrow;
    }
  }

  Future<void> cancelSubscription(String subscriptionId) async {
    try {
      final subscription = await _subscriptionRepository.getSubscriptionById(
        subscriptionId,
      );
      if (subscription == null) return;

      await _subscriptionRepository.cancelSubscription(subscriptionId);

      // Log activity
      await _logActivity(
        ActivityType.subscriptionCancelled,
        'Subscription "${subscription.planName}" was cancelled',
        entityId: subscriptionId,
        entityType: 'Subscription',
        metadata: {
          'student_id': subscription.studentId,
          'plan_name': subscription.planName,
          'remaining_days': subscription.daysRemaining,
        },
      );

      await _loadSubscriptions();
    } catch (error) {
      rethrow;
    }
  }

  Future<void> renewSubscription(
    String subscriptionId,
    DateTime newEndDate,
    double amount,
    {bool allowOverlap = false}
  ) async {
    try {
      final subscription = await _subscriptionRepository.getSubscriptionById(
        subscriptionId,
      );
      if (subscription == null) return;

      await _subscriptionRepository.renewSubscription(
        subscriptionId,
        newEndDate,
        amount,
        allowOverlap: allowOverlap,
      );

      // Log activity
      await _logActivity(
        ActivityType.subscriptionRenewed,
        'Subscription "${subscription.planName}" was renewed',
        entityId: subscriptionId,
        entityType: 'Subscription',
        metadata: {
          'student_id': subscription.studentId,
          'plan_name': subscription.planName,
          'new_end_date': newEndDate.toIso8601String(),
          'renewal_amount': amount,
          'extended_days': newEndDate.difference(subscription.endDate).inDays,
        },
      );

      await _loadSubscriptions();
    } catch (error) {
      rethrow;
    }
  }

  Future<void> deleteSubscription(String subscriptionId) async {
    try {
      final subscription = await _subscriptionRepository.getSubscriptionById(
        subscriptionId,
      );
      if (subscription == null) return;

      await _subscriptionRepository.deleteSubscription(subscriptionId);

      // Log activity
      await _logActivity(
        ActivityType.subscriptionCancelled,
        'Subscription "${subscription.planName}" was deleted',
        entityId: subscriptionId,
        entityType: 'Subscription',
        metadata: {
          'student_id': subscription.studentId,
          'plan_name': subscription.planName,
          'amount': subscription.amount,
        },
      );

      await _loadSubscriptions();
    } catch (error) {
      rethrow;
    }
  }

  Future<List<Subscription>> getSubscriptionsByStudent(String studentId) async {
    try {
      return await _subscriptionRepository.getSubscriptionsByStudent(studentId);
    } catch (error) {
      return [];
    }
  }

  Future<Subscription?> getActiveSubscriptionByStudent(String studentId) async {
    try {
      return await _subscriptionRepository.getActiveSubscriptionByStudent(
        studentId,
      );
    } catch (error) {
      return null;
    }
  }

  Future<List<Subscription>> getExpiringSubscriptions(int days) async {
    try {
      return await _subscriptionRepository.getExpiringSubscriptions(days);
    } catch (error) {
      return [];
    }
  }

  Future<double> getTotalRevenue() async {
    try {
      return await _subscriptionRepository.getTotalRevenue();
    } catch (error) {
      return 0.0;
    }
  }

  Future<double> getRevenueByDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      return await _subscriptionRepository.getRevenueByDateRange(
        startDate,
        endDate,
      );
    } catch (error) {
      return 0.0;
    }
  }

  Future<void> _logActivity(
    ActivityType type,
    String description, {
    String? entityId,
    String? entityType,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final activityLog = ActivityLog(
        id: '', // Will be generated by repository
        activityType: type,
        description: description,
        entityId: entityId,
        entityType: entityType,
        metadata: metadata,
        timestamp: DateTime.now(),
      );

      await _activityLogRepository.createActivityLog(activityLog);
    } catch (error) {
      // Log activity creation should not fail the main operation
    }
  }
}

// Subscriptions notifier provider
final subscriptionsNotifierProvider =
    StateNotifierProvider<
      SubscriptionsNotifier,
      AsyncValue<List<Subscription>>
    >((ref) {
      final subscriptionRepository = ref.watch(subscriptionRepositoryProvider);
      final activityLogRepository = ref.watch(activityLogRepositoryProvider);
      return SubscriptionsNotifier(
        subscriptionRepository,
        activityLogRepository,
      );
    });
